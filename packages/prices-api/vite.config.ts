import { existsSync, readdirSync } from 'node:fs'
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'

import { defineConfig } from 'vite'

const rootDir = dirname(fileURLToPath(import.meta.url))
const srcDir = resolve(rootDir, 'src')
const primitivesSrcDir = 'primitives/src/' as const

/**
 * Rewrites sourcemap source labels for bundled `@primitives` files so published maps don't expose workspace-relative paths.
 * This way we can use @primitives internally, but the published package has no dependencies.
 * @param path Source path label generated by Rollup.
 * @returns A publish-safe source label (for example `primitives/*.ts`).
 */
const rewritePrimitivesPath = (path: string) =>
  path.includes(primitivesSrcDir)
    ? `primitives/${path.slice(path.indexOf(primitivesSrcDir) + primitivesSrcDir.length)}`
    : path

export default defineConfig({
  resolve: { alias: { '@primitives': resolve(rootDir, `../${primitivesSrcDir}`) } },
  build: {
    sourcemap: true,
    lib: { entry: resolve(srcDir, 'index.ts'), formats: ['es'] },
    rollupOptions: {
      input: {
        index: resolve(srcDir, 'index.ts'),
        ...Object.fromEntries(
          readdirSync(srcDir, { withFileTypes: true })
            .filter((entry) => entry.isDirectory() && existsSync(resolve(srcDir, entry.name, 'index.ts')))
            .map((entry) => entry.name)
            .map((name) => [`${name}/index`, resolve(srcDir, name, 'index.ts')]),
        ),
      },
      output: {
        entryFileNames: '[name].js',
        chunkFileNames: 'chunks/[name]-[hash].js',
        sourcemapPathTransform: (relativeSourcePath) =>
          rewritePrimitivesPath(relativeSourcePath.replace(/\\/g, '/') /* remove windows markers if applicable */),
      },
    },
  },
})
